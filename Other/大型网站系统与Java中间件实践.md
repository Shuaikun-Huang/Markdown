# 大型网站系统与Java中间件实践

## 从单机到分布式

### 1. 输入、输出设备的变化：一变多

### 2. 控制器的变化（控制器的作用就是协调或控制节点之间的动作和行为）

- 1）透明代理：中间层对发起方和接收方是透明的

	- 优点：代价低、可控性强，可自由增加负载均衡（即中间层的代理方法，可以理解为控制器）的策略
	- 缺点：增加网络的开销（流量和延迟），代理若出问题，整个未完成的请求会受到影响

- 2）名称服务：取消中间代理，名称服务通过存储接收方地址信息以使发起方与接收方直连

	- 优点：名称服务若出现问题，可有其他方法保证请求不受影响；减少代理带来的额外网络开销
	- 缺点：代码升级复杂

- 3）规则服务：与名称服务类似，但取消规则服务器与接收方的交互，通过提供解码规则给发起方来得到接收方地址

	- 优点：与名称服务相同
	- 缺点：与名称服务相同

- 4）Master+Worker：Master节点管理任务，并给Worker分配任务

### 3. 运算器的变化：一变多（怎么选择哪台运算器）

- DNS：用户在解析DNS时，就被给予一个服务器的地址（类似于名称服务）
- DNS+中间代理（负载均衡--硬件软件都可）：DNS只返回中间代理的地址

### 4. 存储器的变化：把多个存储器视为一个存储器，具体实现与控制器类似

## 分布式系统的难点

### 1. 缺乏全局时钟：单机只有一个时钟，容易控制时序，当多节点发送的消息依赖时序时，需要单独的集群来区分动作的顺序

### 2. 面对故障的独立性（分布式系统常出现一部分出问题一部分正常的情况）：需要找到对应解决故障独立性的方法

### 3. 处理单点故障SPof（Single Point of Failure，某个功能只有一台机器支撑）

- 1）单机到集群
- 2）单点做备份
- 3）降低单点故障影响范围：如进行拆分

### 4. 事务的挑战

## 大型网站及其架构演进过程

### 1. 数据库与应用共存（单机）

### 2. 数据库与应用分离（双机）

### 3. 应用变为集群

- 1）应用服务器选择问题

	- DNS
	- 增加负载均衡器

- 2）session共享问题

	- ★ session sticky：通过负载均衡器来转发经过标识的会话，保证同一个会话的请求每次都在同一台应用服务器上

		- 如果一台应用服务器宕机或重启，保存的会话将会丢失
		- 开销大，会话标识是应用层信息
		- 负载均衡器变为了一个有状态的节点，内存消耗更大

	- session replication：通过对应用服务器增加会话数据同步，使每台应用服务器都有一样的session

		- 同步session带来额外的带宽消耗
		- 每台应用服务器要保存所有session，内存消耗大

	- ★ session集中存储：多台应用服务器访问统一个session存储器

		- 读写session引入网络操作，存在延时和不稳定性，内网下影响低
		- 存储session的机器出问题会影响应用

	- cookie based：通过cookie来传递session数据

		- cookie长度有限制
		- 安全性不足，session暴露在cookie中（可通过加密session解决）
		- 存在额外带宽消耗
		- 性能有所降低，每次请求都携带session数据，使得支持并发请求的数量下降

### 4. 数据库读写分离（主库与备库）

- 问题

	- 1）数据复制问题：数据存在短期不一致现象
	- 2）数据源选择问题

- 缓存

	- 1）数据缓存：分担数据库读的压力

		- 在缓存中存放热数据，应用先访问缓存，如果缓存中没有所需数据，则从数据库读出数据放入缓存
		- 数据库在发生数据变化后，主动把数据放入缓存

	- 2）页面缓存：对比较热的页面部分进行内容缓存（ESI规范）

### 5. 分布式存储系统（文件+key-value+数据库）：弥补关系型数据库的不足

- 分布式文件系统：解决小文件和大文件的存储问题
- 分布式key-value系统：提供高性能的半结构化支持
- 分布式数据库：提供一个支持大数据、高并发的数据库系统

### 6. 数据库主库拆分

- 1）垂直拆分：根据业务（商品、用户）的不同进行拆分

	- 问题：如何处理跨业务事务

		- 使用分布式事务，性能低
		- 不使用事务

- 2）水平拆分：垂直拆分后，把同一个表中的数据拆分到两个数据库

	- sql路由问题：需要知道操作的数据在哪
	- 主键问题：主键唯一性得不到保证
	- 查询问题：需要跨数据库关联查询数据

### 7. 应用功能越来越多

- 1）根据业务拆分为多个应用服务器：如何复用相似的代码
- 2）服务化（应用系统+服务中心+业务数据库）

	- 应用系统：完成不同业务功能
	- 服务中心：不同的服务中心提供不同的业务服务

		- 优点1：每个部分都可由固定的团队来维护，提高稳定性
		- 优点2：之前散落的共享代码集中在服务中心
		- 优点3：让前端更加注重与浏览器的交互，不用过分关注业务逻辑
		- 优点4：数据库的访问交给服务中心，降低了数据可的连接数

	- 业务数据库

### 8. 消息中间件：完成分布式系统中消息的发送和接收，使收发消息双方不直接联系，实现异步解耦

## 服务框架设计与实现（服务化结构）

### 1. 获取可用服务地址清单并确定要调用服务的目标机器

- 1）透明代理（负载均衡）
- 2）服务注册查找中心+直连

### 2. 寻址路由：让调用方确定哪个实例被调用

- 基于接口，方法和参数：线程池会受到慢接口影响

	- 加机器，增加可执行的线程总数
	- 按重要度对不同资源进行隔离（分类），路由到不同机器

### 3. 请求信息序列化

### 4. 通信（NIO）

### 5. 请求信息反序列化

### 6. 实例定位：让被调用方确定哪个实例被调用

- 若客户端没有通过接口或方法进行路由，可在服务端进行线程程隔离

### 7. 服务调用

### 其他

- 1. 多机房场景
- 2. 服务调用端流控处理：保证系统稳定性

	- 策略1：完全打开或完全不打开
	- 策略2：设定固定值（每秒），超过这个值，则拒绝远程请求

- 3. 多种调用方式

	- 1）同步调用

		- IO线程：专门用于与socket连接并进行数据的收发，不用每个请求线程都与socket打交道
		- 数据队列：需要发送的数据会进入数据队列，需掌握好数据队列的长度
		- 通信对象队列：保存多个线程使用的通信对象
		- 定时任务：计时

	- 2）oneway：发送请求后，继续处理，而不关心对方是否受到请求或返回结果
	- 3）callback：发送请求后，继续处理，待对方有相应后进行回调
	- 4）future：发送请求和后续处理完成后，通过future获取通信结果并直接控制超时
	- 5）可靠异步：需要依靠消息中间件保证请求在远程被执行

## 数据访问层

### 1. 分布式事务

- 1）分布式事务处理模型-DTP模型（X/Open组织）

	- 三大组件

		- Application Program（AP）- 定义了事务边界
		- Resource Manager（RM）- AP通过资源管理器对资源进行控制
		- Transaction Manager（TM）- 事务管理器，负责协调和管理事务

- 2）两阶段提交（2PC）：在提交前增加准备阶段

	- 会使分布式事务的开销增大

		- 事务管理器与多个资源进行协调，增加日志记录工作
		- 网络上交互次数增多

- 3）CAP理论

	- 数据一致性（Consistency）：所有节点在同一时刻读到同样的数据
	- 数据可用性（Availability）：无论成功失败，每个请求都能收到一个反馈
	- 分区容错性（Partition-Tolerance）：系统中有部分问题或者消息丢失，系统能够继续运行

- 4）CAP搭配：分布式系统中不能同时满足上面三项，首先满足AP，再解决C的问题

	- CA：一致性和可用性，如单机数据库
	- AP：放弃一致性，大部分系统的选择
	- CP：放弃可用性，网络问题会让系统不可用

- 5）BASE模型

	- Basically Available：基本可用，允许分区失败
	- Soft state：软状态，接收一段时间状态的不同步
	- Eventually consistent：保证数据状态，最终一致

- 6）Paxos协议：比两阶段提交要轻量且保证一致性的协议

### 2. 多机中序列问题：单机中自增ID

- 解决方向

	- 1）唯一性

		- 根据IP，MAC，时间等生成唯一的ID

	- 2）连续性

		- 通过一个单独的存储器来存储每个ID序列当前最大值，控制并发更新，再由ID生成器一次生成一段ID

			- 问题

				- 性能问题：每次都要远程取ID，造成资源损耗
				- 生成器稳定性问题
				- 存储问题：空间大小，容灾等

### 3. 多机中的数据查询

- 1）跨库join问题：需要合并的数据不在一个库中

	- 同一用户相关数据放在同一个库中
	- 借助外部系统，如搜索引擎
	- 将常用信息进行冗余

- 2）外键约束
- 3）跨库查询

	- 存在的问题

		- 排序问题：多个数据库已经排序情况下，取出结果使用归并排序，反则需要全排序
		- 函数处理：如Max，Min等
		- 求平均值
		- 非排序分页：按一定规律将多个数据进行分页显示

			- 同等步长
			- 同等比例

		- 排序后分页：最复杂的情况，尽量避免在访问量很大的系统中使用，尤其是排序后需要翻很多页的情况

### 4. 数据层提供访问的方式

- 1）专有API：通用性极差，但便于实现，特定场景使用
- 2）JDBC访问：Java数据库连接，兼容性和扩展性最好，实现成本较高
- 3）基于ORM或类ORM接口方式：介于上面两者之间

### 5. 数据层处理流程

- 1）SQL解析

	- sql的支持程度：是否支持所有sql
	- 支持多少sql方言

- 2）规则处理

	- 固定的哈希算法：先用哈希算法将不同长度的输入变为相同长度的哈希值，然后对哈希值进行取模进行分配库或表

		- 缺点：如果系统进行扩容，会造成大部分数据的迁移

	- 一致性哈希算法：将节点的哈希值用一个范围来表示，进行扩容，进行迁移的数据较少

		- 缺点：当减少节点时，会使承担减去节点工作的节点压力增加

			- 在每个节点范围上增加多个虚拟节点

	- 映射表：根据分库分表字段的值的查表法来确定数据源，一般用于对热点数据的特殊处理
	- 规则自定义：最灵活

- 3）改写SQL：多库多表中存在多个库名或表名
- 4）选择数据源：确定具体的某个数据源
- 5）执行SQL：难点在于对异常的处理

### 6. 读写分离的挑战

- 1）主(Master)从(Slave)不对称的复制

	- 数据结构相同，多从库一主库

		- 数据层向消息系统投放通知，数据同步服务器接收通知并更新Slave
		- 基于数据库日志进行复制

	- 不对称复制：源数据和目标数据不是镜像关系，或源数据库和目标数据库是不同实现
	- 数据库平台的变更

		- 使用Extractor和Applier进行分发

- 2）扩容缩容时的数据迁移：扩容缩容时，出现数据的变化

	- 使用日志记录迁移时发生的增量，迁移完成后再进行处理，处理过程中国暂停数据可写权限，待处理完成后再打开

## 消息中间件

### 1. 作用

- 1）异步操作
- 2）应用之间的解耦

### 2. 消息发送一致性：产生消息的业务动作与消息发送一致，即业务成功，消息一定要发送成功，反之亦然

- 1）JMS（Java Message Service）：java中的一个关于消息的规范，成本高
- 2）其他解决流程

	- 1）应用发送消息给中间件，并标记状态为待处理
	- 2）将状态消息进行存储
	- 3）返回给应用存储成功与否
	- 4）业务进行操作
	- 5）发送业务操作结果给中间件，并修改之前存储的状态

- 3）可能出现情况

	- 1）业务操作未进行，消息未进入存储（不需要额外处理）
	- 2）业务操作未进行，消息存入存储，状态为待处理
	- 3）业务操作成功，消息存入存储，状态为待处理

- 4）方案存在的限制

	- 需要确定要发送的消息内容
	- 需要实现对业务的检查

### 3. 消息中间件与使用者强依赖问题：如果消息中间件出现问题，会导致业务操作不能继续进行

- 方案

	- 1）提升消息中间件的可靠性
	- 2）保证业务操作成功，状态信息存储成功

		- 将业务操作需要的数据表和中间件需要的消息表都放在业务操作数据库中

	- 3）提供弱依赖的支持

### 4. 消息模型

- 1）JMS Queue模型（点对点）：连接到队列上的消息订阅者分摊所有消息
- 2）JMS Topic模型（发布/订阅）：连接到队列上的消息订阅者都可以接收所有消息
- 3）两者的融合：解决消息订阅者为集群的情况

### 5. 消息订阅者订阅消息的方式

- 1）持久订阅：建立订阅除非显式取消订阅，否则订阅关系一直都在，消息会保留到下次应用建立连接后再投递
- 2）非持久订阅：建立订阅即可收到消息，取消订阅即收不到消息

### 6. 保证消息可靠性：基于持久订阅前提下，从三个阶段去保证消息可靠性

- 1）消息发送端可靠性
- 2）消息存储可靠性：消息存储在外存上

	- 基于文件的消息存储
	- 基于数据库的消息存储
	- 基于双机内存的消息存储：采用双机内存来存储消息，一旦一台机器出问题，将另外一台内存中的数据进行落盘（持久存储）

- 3）消息投递可靠性

	- 消息投递的优化1：不因某个线程处理慢而影响了后续的处理

		- 投递时采用多线程
		- 将处理消息结果返回的工作放到另外的线程池去做

	- 消息投递的优化2：一个应用上有多个订阅者订阅同样的消息

### 7. 消息系统扩容

- 1）消息中间件自身扩容：一个或多个消息中间件共用一个或多个消息存储设备

	- 问题：同一个存储怎么区分消息来自于哪个消息中间件

		- 给每条消息增加一个server标识的字段

- 2）消息存储设备扩容

	- 消息存储设备扩容的优势

		- 不用考虑消息的顺序
		- 不用考虑服务器要主动获取消息

	- 实现方法：通过服务端主动调度安排投递的方式绕开根据消息ID获取消息的动作

### 8. 消息重复

- 1）产生原因

	- 消息成功进入消息存储后，因为各种原因使得消息发送端没有收到“成功”的返回结果
	- 消息接收者成功处理完消息后，消息中间件不能及时更新投递状态

		- 采用分布式事务，成本高，比较复杂

			- 重新发送消息时用相同消息ID

		- 消息接收者的消息处理是幂等操作：重复运算的结果等于它本身

- JMS消息确认方式可避免

### 9. 消息投递的其他属性

- 1）消息优先级：优先级高的先投递，不按先到先投递
- 2）订阅者消息处理顺序和分级订阅
- 3）自定义属性：消息自身可创建时间、类型、投递次数等属性
- 4）局部顺序

## 软负载中心

### 1. 作用

- 1）聚合地址信息，提供可用服务列表

	- 保证数据的正确性
	- 高效聚合数据

- 2）生命周期感知，感知服务的上下线，并更新服务的地址数据

	- 通过客户端与服务端的连接感知，长时间没有心跳或数据的发布，即判断不在线
	- 通过发布数据中提供的地址端口进行连接的检查

### 2. 结构

- 1）服务端：负责感知提供服务的机器是否在线，并聚合其机器信息，然后把数据传给使用数据的应用
- 2）客户端

	- 作为服务提供的客户端，作用是将服务具体信息主动传给服务端，并根据提供服务的变化更新数据
	- 作为服务使用的客户端，作用是向服务端告知自己所需的数据

- 3）数据构成

	- 聚合数据：地址信息列表
	- 订阅关系：服务使用者把自己需要的数据信息通知软负载中心，这就是一个订阅关系
	- 连接数据：连接到软负载中心的节点和已经建立的连接的管理

### 3. 集群软负载中心

- 1）存在的问题

	- 数据关系问题：数据该怎么维护和保存
	- 连接管理问题

- 2）解决方案1--数据统一管理

	- 数据存放在一个地方，软负载中心职责拆分，每台负责专门的职责，如推送与聚合

- 3）解决方案2--数据对等管理

	- 数据分散到各个软负载中心的节点，且每个节点都有整个集群的全部数据，这些节点的角色是对等的

		- 存在数据同步问题

## 集中配置管理

### 1. 软负载中心除了服务地址列表外，还存在路由规则和消息订阅关系等数据，这些数据根据是否持久以及是否需要聚合进行分类

### 2. 分类

- 1）持久：数据本身与发布者生命周期无关

	- 持久订阅关系
	- 路由规则
	- 分库分表规则

- 2）非持久

	- 服务地址列表

- 3）聚合

	- 服务地址列表、订阅关系等数据需要聚合
	- 路由规则和一些设置数据不用聚合

### 3. 作用

- 软负载中心管理非持久数据
- 集中配置管理中心负责管理持久数据

### 4. 关心问题

- 1）首先保证其稳定性和异常下的容灾策略

	- 通过主备的持久存储保存持久数据，一般采用关系型数据库
	- 容灾通过集群中每个单机中的本地文件

- 2）次要保证数据分发的延迟

## 构建大型网站的其他要素

### 1. CDN（内容分发网络）加速

- 1）作用：把用户需要的稳定资源放到用户较近的地方
- 2）优点：其本质是网络缓存技术

	- 节省整个宽域网的带宽消耗
	- 提升用户的访问速度

- 3）访问流程

	- 未使用CDN：用户提交域名==》浏览器解析域名==》根据解析出来的IP地址发送请求==》浏览器根据返回的数据进行显示
	- 使用CDN：用户提交域名==》浏览器解析域名==》查看CDN本地是否有该域名内容==》有则返回内容，没有则CDN向源网进行请求，再返回

- 4）关键技术

	- 全局调度
	- 缓存技术
	- 内容分发
	- 带宽优化

### 2. 大型网站的存储支持

- 1）分布式文件系统：对于图片、大文本的存储
- 2）NoSQL：处于分布式文件系统和SQL关系型数据库之间的系统都被归为NoSQL

### 3. 缓存系统

- 1）开源缓存系统

	- Redis
	- Memcache

- 2）缓存使用场景

	- 降低应用对底层存储的读压力

		- 缓存的3种使用方式

	- 对Web应用的也缪按渲染内容进行缓存

### 4. 搜索系统：站内搜索

- 1）数据量小的网站：直接用数据库的like操作
- 2）爬虫问题：通过爬虫取获取被检索的网站的网页信息
- 3）倒排索引：相对于正排索引，倒排索引是把原来作为值的内容拆分为索引的key，而原来的key变为值
- 4）查询预处理：对用户输入的搜索内容进行分词及分词后的分析，如同义词替换，纠错等
- 5）相关度计算：对于搜索返回的结果，需要经过计算搜索内容的相关度后展示给用户

### 5. 数据计算支撑

- 1）离线计算

	- 定义：业务产生的数据离开生产环境后的计算，业务从在线存储移动到离线存储后再进行数据处理
	- Hadoop的MapReduce开源实现

		- Map：按设定规则将数据映射给不同的Worker处理，生成各自结果
		- Reduce：对处理过的数据聚合，形成最后结果

- 2）在线计算（流式计算）

### 6. 发布系统

- 1）分发应用：P2P技术，提高分发速度
- 2）启动校验：新应用重启后，需要进行校验(不太清除为什么需要这一步)
- 3）灰度发布：对新应用进行分批发布，并逐步扩大到整个集群
- 4）产品改版Beta：产品更新会改变用户习惯，对于这样的改变，不进行一刀切推行，而是新旧应用共存

### 7. 应用监控系统：了解应用的运行状况并进行相应的控制

- 1）监控
- 2）控制

### 8. 依赖管理系统：根据强依赖和弱依赖进行依赖管理

### 9. 系统容量规划

- 1）清除当前系统高峰期水位在多少
- 2）当前各个系统容量多少
- 3）设置警戒值，高于就增加容量，保持高峰水位低于警戒值
